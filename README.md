# go-tasks-l1
Задачи для освоения языка Go | WB Техношкола

# Задача 1

Дана структура Human (с произвольным набором полей и методов).
Реализовать встраивание методов в структуре Action от родительской структуры Human (аналог наследования).

**Запуск решения:** `cd 1 && go build && ./1 && cd ..` | `make task1`

# Задача 2 

Написать программу, которая конкурентно рассчитает значения квадратов чисел, взятых из массива [2,4,6,8,10], и выведет результаты в stdout.

**Запуск решения:** `cd 2 && go build && ./2 && cd ..` | `make task2`

# Задача 3

Реализовать постоянную запись данных в канал (в главной горутине).

Реализовать набор из N воркеров, которые читают данные из этого канала и выводят их в stdout.

Программа должна принимать параметром количество воркеров и при старте создавать указанное число горутин-воркеров.

**Запуск решения:** `cd 3 && go build && ./3 && cd ..` | `make task3`

# Задача 4

Программа должна корректно завершаться по нажатию Ctrl+C (SIGINT).

Выберите и обоснуйте способ завершения работы всех горутин-воркеров при получении сигнала прерывания.

Подсказка: можно использовать контекст (context.Context) или канал для оповещения о завершении.

**Запуск решения:** `cd 4 && go build && ./4 && cd ..` | `make task4`

# Задача 5

Разработать программу, которая будет последовательно отправлять значения в канал, а с другой стороны канала – читать эти значения. По истечении N секунд программа должна завершаться.

Подсказка: используйте time.After или таймер для ограничения времени работы.

**Запуск решения:** `cd 5 && go build && ./5 && cd ..` | `make task5`

# Задача 6

Реализовать все возможные способы остановки выполнения горутины.

Классические подходы: выход по условию, через канал уведомления, через контекст, прекращение работы runtime.Goexit() и др.

Продемонстрируйте каждый способ в отдельном фрагменте кода.

**Запуск решения:** `cd 6 && go build && ./6 && cd ..` | `make task6`

# Задача 7

Реализовать безопасную для конкуренции запись данных в структуру map.

Подсказка: необходимость использования синхронизации (например, sync.Mutex или встроенная concurrent-map).

Проверьте работу кода на гонки (util go run -race).

**Запуск решения:** `cd 7 && go build -race && ./7 && cd ..` | `make task7`

# Задача 8 

Дана переменная типа int64. Разработать программу, которая устанавливает i-й бит этого числа в 1 или 0.

Пример: для числа 5 (0101₂) установка 1-го бита в 0 даст 4 (0100₂).

Подсказка: используйте битовые операции (|, &^).

**Запуск решения:** `cd 8 && go build && ./8 && cd ..` | `make task8`

# Задача 9

Разработать конвейер чисел. Даны два канала: в первый пишутся числа x из массива, во второй – результат операции x*2. После этого данные из второго канала должны выводиться в stdout. То есть, организуйте конвейер из двух этапов с горутинами: генерация чисел и их обработка. Убедитесь, что чтение из второго канала корректно завершается.

**Запуск решения:** `cd 9 && go build && ./9 && cd ..` | `make task9`

# Задача 10

Дана последовательность температурных колебаний: -25.4, -27.0, 13.0, 19.0, 15.5, 24.5, -21.0, 32.5. Объединить эти значения в группы с шагом 10 градусов.

Пример: -20:{-25.4, -27.0, -21.0}, 10:{13.0, 19.0, 15.5}, 20:{24.5}, 30:{32.5}.

Пояснение: диапазон -20 включает значения от -20 до -29.9, диапазон 10 – от 10 до 19.9, и т.д. Порядок в подмножествах не важен.

**Запуск решения:** `cd 10 && go build && ./10 && cd ..` | `make task10`


# Задание 11

Реализовать пересечение двух неупорядоченных множеств (например, двух слайсов) — т.е. вывести элементы, присутствующие и в первом, и во втором.

Пример:
A = {1,2,3}
B = {2,3,4}
Пересечение = {2,3}


**Запуск решения:** `cd 11 && go build && ./11 && cd ..` | `make task11`


# Задание 12

Имеется последовательность строк: ("cat", "cat", "dog", "cat", "tree"). Создать для неё собственное множество.

Ожидается: получить набор уникальных слов. Для примера, множество = {"cat", "dog", "tree"}.

**Запуск решения:** `cd 12 && go build && ./12 && cd ..` | `make task12`

# Задание 13

Поменять местами два числа без использования временной переменной.

Подсказка: примените сложение/вычитание или XOR-обмен.

**Запуск решения:** `cd 13 && go build && ./13 && cd ..` | `make task13`

# Задание 14

Разработать программу, которая в runtime способна определить тип переменной, переданной в неё (на вход подаётся interface{}). Типы, которые нужно распознавать: int, string, bool, chan (канал).

Подсказка: оператор типа switch v.(type) поможет в решении.

**Запуск решения:** `cd 14 && go build && ./14 && cd ..` | `make task14`

# Задание 15

Рассмотреть следующий код и ответить на вопросы: к каким негативным последствиям он может привести и как это исправить?

Приведите корректный пример реализации.

var justString string

func someFunc() {
  v := createHugeString(1 &lt;&lt; 10)
  justString = v[:100]
}

func main() {
  someFunc()
}

**Запуск решения:** `cd 15 && go build && ./15 && cd ..` | `make task15`


# Задание 16

Реализовать алгоритм быстрой сортировки массива встроенными средствами языка. Можно использовать рекурсию.

Подсказка: напишите функцию quickSort([]int) []int которая сортирует срез целых чисел. Для выбора опорного элемента можно взять середину или первый элемент.

**Запуск решения:** `cd 16 && go build && ./16 && cd ..` | `make task16`

# Задание 17

Реализовать алгоритм бинарного поиска встроенными методами языка. Функция должна принимать отсортированный слайс и искомый элемент, возвращать индекс элемента или -1, если элемент не найден.

Подсказка: можно реализовать рекурсивно или итеративно, используя цикл for.

**Запуск решения:** `cd 17 && go build && ./17 && cd ..` | `make task17`


# Задание 18

Реализовать структуру-счётчик, которая будет инкрементироваться в конкурентной среде (т.е. из нескольких горутин). По завершению программы структура должна выводить итоговое значение счётчика.

Подсказка: вам понадобится механизм синхронизации, например, sync.Mutex или sync/Atomic для безопасного инкремента.

**Запуск решения:** `cd 18 && go build && ./18 && cd ..` | `make task18`

# Задание 19

Разработать программу, которая переворачивает подаваемую на вход строку.

Например: при вводе строки «главрыба» вывод должен быть «абырвалг».

Учтите, что символы могут быть в Unicode (русские буквы, emoji и пр.), то есть просто iterating по байтам может не подойти — нужен срез рун ([]rune).

**Запуск решения:** `cd 19 && go build && ./19 && cd ..` | `make task19`

# Задание 20

Разработать программу, которая переворачивает порядок слов в строке.

Пример: входная строка:

«snow dog sun», выход: «sun dog snow».

Считайте, что слова разделяются одиночным пробелом. Постарайтесь не использовать дополнительные срезы, а выполнять операцию «на месте».

**Запуск решения:** `cd 20 && go build && ./20 && cd ..` | `make task20`


# Задание 21

Реализовать паттерн проектирования «Адаптер» на любом примере.

Описание: паттерн Adapter позволяет сконвертировать интерфейс одного класса в интерфейс другого, который ожидает клиент.

Продемонстрируйте на простом примере в Go: у вас есть существующий интерфейс (или структура) и другой, несовместимый по интерфейсу потребитель — напишите адаптер, который реализует нужный интерфейс и делегирует вызовы к встроенному объекту.

Поясните применимость паттерна, его плюсы и минусы, а также приведите реальные примеры использования.

**Запуск решения:** `cd 21 && go build && ./21 && cd ..` | `make task21`


# Задание 22

Разработать программу, которая перемножает, делит, складывает, вычитает две числовых переменных a, b, значения которых > 2^20 (больше 1 миллион).

Комментарий: в Go тип int справится с такими числами, но обратите внимание на возможное переполнение для ещё больших значений. Для очень больших чисел можно использовать math/big.

**Запуск решения:** `cd 22 && go build && ./22 && cd ..` | `make task22`


# Задание 23

Удалить i-ый элемент из слайса. Продемонстрируйте корректное удаление без утечки памяти.

Подсказка: можно сдвинуть хвост слайса на место удаляемого элемента (copy(slice[i:], slice[i+1:])) и уменьшить длину слайса на 1.


**Запуск решения:** `cd 23 && go build && ./23 && cd ..` | `make task23`

# Задание 24

Разработать программу нахождения расстояния между двумя точками на плоскости. Точки представлены в виде структуры Point с инкапсулированными (приватными) полями x, y (типа float64) и конструктором. Расстояние рассчитывается по формуле между координатами двух точек.

Подсказка: используйте функцию-конструктор NewPoint(x, y), Point и метод Distance(other Point) float64.

**Запуск решения:** `cd 24 && go build && ./24 && cd ..` | `make task24`